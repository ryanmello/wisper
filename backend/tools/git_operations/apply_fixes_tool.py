"""
Apply Fixes Tool - Apply file changes to repository
"""

import os
from typing import Dict, Any, List
from langchain_core.tools import tool

from utils.logging_config import get_logger

logger = get_logger(__name__)

@tool
def apply_fixes(repository_path: str, fixes: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Apply file changes to repository based on suggested fixes from security or code analysis tools.
    
    This tool takes specific fix recommendations (typically from security analysis tools) and applies them 
    to the repository files. It's useful when you want to automatically remediate identified issues such as 
    security vulnerabilities, code quality problems, or dependency updates. Use this after analysis tools 
    have identified specific actionable fixes.
    
    Prerequisites: Repository must be cloned; fixes should be generated by analysis tools
    Often followed by: create_pull_request to submit the applied fixes
    
    Args:
        repository_path: Path to the cloned repository where fixes should be applied
        fixes: List of fix objects containing file paths and changes to apply
        
    Returns:
        Dictionary with applied changes, success status, and summary of modifications
    """
    logger.info(f"Applying fixes to {len(fixes)} files in {repository_path}")
    
    try:
        if not fixes:
            return {
                "status": "success",
                "files_modified": 0,
                "message": "No file changes to apply"
            }
        
        applied_files = []
        failed_files = []
        
        for fix in fixes:
            file_path = fix["file"]
            new_content = fix["content"]
            try:
                # Resolve full file path
                full_path = os.path.join(repository_path, file_path)
                
                # Ensure directory exists
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                
                # Create backup of original file if it exists
                backup_created = False
                if os.path.exists(full_path):
                    backup_path = full_path + '.backup'
                    try:
                        import shutil
                        shutil.copy2(full_path, backup_path)
                        backup_created = True
                    except Exception as e:
                        logger.warning(f"Failed to create backup for {file_path}: {e}")
                
                # Write new content
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(new_content)
                
                applied_files.append({
                    "file": file_path,
                    "status": "success",
                    "backup_created": backup_created
                })
                
                logger.debug(f"Applied fixes to {file_path}")
                
            except Exception as e:
                logger.error(f"Failed to apply fixes to {file_path}: {e}")
                failed_files.append({
                    "file": file_path,
                    "error": str(e)
                })
        
        result = {
            "status": "success" if not failed_files else "partial_success",
            "files_modified": len(applied_files),
            "files_failed": len(failed_files),
            "applied_files": applied_files,
            "failed_files": failed_files,
            "message": f"Applied fixes to {len(applied_files)} files"
        }
        
        if failed_files:
            result["message"] += f", {len(failed_files)} files failed"
        
        logger.info(f"Fix application complete - {len(applied_files)} successful, {len(failed_files)} failed")
        return result
        
    except Exception as e:
        logger.error(f"Failed to apply fixes: {e}")
        return {
            "status": "error",
            "error": str(e),
            "files_modified": 0,
            "files_failed": len(fixes),
            "message": "Failed to apply fixes"
        } 